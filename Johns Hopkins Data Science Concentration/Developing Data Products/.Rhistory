set.seed(500)
data <- Boston
apply(data,2,function(x) sum(is.na(x)))
index <- sample(1:nrow(data),round(0.75*nrow(data)))
train <- data[index,]
test <- data[-index,]
lm.fit <- glm(medv~., data=train)
pr.lm <- predict(lm.fit,test)
library(ggplot2)
qplot(medv, pr.lm, data=testing)
qplot(medv, pr.lm, data=test)
plot(lm.fit)
maxs <- apply(data, 2, max)
mins <- apply(data, 2, min)
scaled <- as.data.frame(scale(data, center = mins, scale = maxs - mins))
train_ <- scaled[index,]
test_ <- scaled[-index,]
library(neuralnet)
n <- names(train_)
n
f <- as.formula(paste("medv ~", paste(n[!n %in% "medv"], collapse = " + ")))
f
?neuralnet
nn <- neuralnet(f,data=train_,hidden=c(5,3),linear.output=T)
summary(nn)
plot(nn)
str(test_)
prediction(nn)
pr.nn <- compute(nn,test_[,1:13])
pr.nn
pr.nn_ <- pr.nn$net.result*(max(data$medv)-min(data$medv))+min(data$medv)
test.r <- (test_$medv)*(max(data$medv)-min(data$medv))+min(data$medv)
MSE.nn <- sum((test.r - pr.nn_)^2)/nrow(test_)
print(paste(MSE.lm,MSE.nn))
MSE.lm <- sum((pr.lm - test$medv)^2)/nrow(test)
MSE.nn <- sum((test.r - pr.nn_)^2)/nrow(test_)
print(paste(MSE.lm,MSE.nn))
par(mfrow=c(1,2))
plot(test$medv,pr.nn_,col='red',main='Real vs predicted NN',pch=18,cex=0.7)
abline(0,1,lwd=2)
legend('bottomright',legend='NN',pch=18,col='red', bty='n')
plot(test$medv,pr.lm,col='blue',main='Real vs predicted lm',pch=18, cex=0.7)
abline(0,1,lwd=2)
legend('bottomright',legend='LM',pch=18,col='blue', bty='n', cex=.95)
plot(test$medv,pr.nn_,col='red',main='Real vs predicted NN',pch=18,cex=0.7)
points(test$medv,pr.lm,col='blue',pch=18,cex=0.7)
abline(0,1,lwd=2)
plot(test$medv,pr.nn_,col='red',main='Real vs predicted NN',pch=18,cex=0.7)
points(test$medv,pr.lm,col='blue',pch=18,cex=0.7)
abline(0,1,lwd=2)
legend('bottomright',legend=c('NN','LM'),pch=18,col=c('red','blue'))
par(mfrow=c(1,1))
plot(test$medv,pr.nn_,col='red',main='Real vs predicted NN',pch=18,cex=0.7)
points(test$medv,pr.lm,col='blue',pch=18,cex=0.7)
abline(0,1,lwd=2)
legend('bottomright',legend=c('NN','LM'),pch=18,col=c('red','blue'))
?abline
library(boot)
set.seed(200)
lm.fit <- glm(medv~.,data=data)
cv.glm(data,lm.fit,K=10)$delta[1]
set.seed(450)
cv.error <- NULL
k <- 10
?cv.glm
?credit
library(caret)
?credit
head(credit)
Library(fma)
library(fma)
head(credit)
library(fpp)
head(credit)
class(credit)
str(credit)
?sunspotarea
class(sunspotarea)
head(sunspotarea)
creditN <- scale(credit)
head(creditN)
creditN[50,4:5]
creditN[1:50,4:5]
sunNorm <- scale(sunspotarea)
head(sunNorm)
class(creditN)
class(sunNorm)
sunNormTs <- as.ts(sunNorm)
class(sunNormTs)
head(sunNormTs)
install.packages("timeSeries")
TimeSun <- getTime(sunspotarea)
library(timeSeries)
TimeSun <- getTime(sunspotarea)
class(TimeSun)
TimeSun
setTime(sunNormTs) <- TimeSun
sunNormTime <- time(sunNormTs)
class(sunNormTime)
setTime(sunNormTs) <- time(TimeSun)
vignette(timeSeries)
sunTime <- time(sunspotarea)
class(sunTime)
sunTimeVec <- as.vector(sunTime)
setTime(sunNormTs) <- sunTimeVec
sunNormTs2 <- as.timeSeries(sunNormTs)
class(sunNormTs2)
setTime(sunNormTs2) <- TimeSun
head(sunNormTs2)
head(sunspotarea)
sunNormRegTs <- as.ts(sunNormTs2)
head(sunNormRegTs)
fit <- auto.arima(sunNormTs2)
fit
autoplot(fit)
autoplot(sunNormTs2)
fcast <- forecast(fit)
autoplot(fcast)
?sunspotarea
str(sunspotarea)
qplot(sunNormTs2)
class(sunNormTs2)
?`as.ts
?as.ts
sunspotNorm <- as.ts(sunNorm, start = 1875, end = 2011, frequency = 1)
class(sunspotNorm)
str(sunspotNorm)
str(sunspotarea)
dimnames(sunspotNorm)
head(sunspotNorm)
autoplot(sunspotNorm)
sunspotNorm <- ts(sunNorm, start = 1875, end = 2011, frequency = 1)
str(sunspotNorm)
autoplot(sunspotNorm)
str(creditlog)
?scale
creditN2 <- scale(credit, center=TRUE, scale=TRUE)
head(creditN2)
head(creditN)
library(caret); library(fpp)
creditlog  <- data.frame(score=credit$score,
log.savings=log(credit$savings+1),
log.income=log(credit$income+1),
log.address=log(credit$time.address+1),
log.employed=log(credit$time.employed+1),
fte=credit$fte, single=credit$single)
creditlogN <- as.dataframe(scale(creditlog))
creditlogN <- as.data.frame(scale(creditlog))
head(creditlogN)
fit  <- avNNet(score ~ log.savings + log.income + log.address +
log.employed, data=creditlog, repeats=25, size=3, decay=0.1,
linout=TRUE)
fit  <- avNNet(score ~ log.savings + log.income + log.address +
log.employed, data=creditlogN, repeats=25, size=3, decay=0.1,
linout=TRUE)
fit
summary(fit)
str(fit)
print(fit)
?avNNet
fit$model
fit$repeats
fit$names
fcast <- forecast(fit, PI=T, h=20)
fcast <- forecast(fit)
inTrain <- createDataPartition(y=creditlog$score,
p=0.7, list=FALSE)
training <- creditlog[inTrain,]; testing <- creditlog[-inTrain,]
dim(training); dim(testing)
head(training)
inTrainN <- createDataPartition(y=creditlogN$score,
p=0.7, list=FALSE)
trainingN <- creditlogN[inTrain,]; testingN <- creditlogN[-inTrain,]
dim(trainingN); dim(testingN)
head(trainingN)
fit  <- avNNet(score ~ log.savings + log.income + log.address +
log.employed, data=training, repeats=25, size=3, decay=0.1,
linout=TRUE)
fitN  <- avNNet(score ~ log.savings + log.income + log.address +
log.employed, data=trainingN, repeats=25, size=3, decay=0.1,
linout=TRUE)
pred <- predict(fit, newdata = testing)
predN <- predict(fitN, newdata = testingN)
pred
confusionMatrix(testing$score, pred)
testing$score
length(pred)
length(testing$score)
summary(pred)
summary(fit$model)
print(fit$model)
RMSE <- sqrt(sum(testing$score-pred)^2/nrow(testing))
RMSEN <- sqrt(sum(testingN$score-predN)^2/nrow(testingN))
print(paste(RMSE,RMSEN))
mean(testing$score)
mean(testingN$score)
predNdenorm <- pred*(sd(creditlog$score))+mean(creditlog$score)
testingNdenorm <- testingN$score*(sd(creditlog$score))+mean(creditlog$score)
RMSEN <- sqrt(sum(testingNdenorm-predNdenorm)^2/nrow(testingN))
print(paste(RMSE,RMSEN))
sd(creditlog$score)
sum(testingNdenorm-predNdenorm)^2/nrow(testingN)
df <- cbind(testingNd = testingNdenorm, testing=testing$score)
head(df)
RMSEN2 <- sqrt(sum(testingNdenorm-predNdenorm)^2/nrow(testingN))
RMSEN2
predNdenorm
library(caret); library(fpp)
creditlog  <- data.frame(score=credit$score,
log.savings=log(credit$savings+1),
log.income=log(credit$income+1),
log.address=log(credit$time.address+1),
log.employed=log(credit$time.employed+1),
fte=credit$fte, single=credit$single)
fit  <- avNNet(score ~ log.savings + log.income + log.address +
log.employed, data=creditlog, repeats=25, size=3, decay=0.1,
linout=TRUE)
creditlogN <- as.data.frame(scale(creditlog))
fitN  <- avNNet(score ~ log.savings + log.income + log.address +
log.employed, data=creditlogN, repeats=25, size=3, decay=0.1,
linout=TRUE)
class(credit)
head(credit)
inTrain <- createDataPartition(y=creditlog$score,
p=0.7, list=FALSE)
training <- creditlog[inTrain,]; testing <- creditlog[-inTrain,]
trainingN <- creditlogN[inTrain,]; testingN <- creditlogN[-inTrain,]
fit  <- avNNet(score ~ log.savings + log.income + log.address +
log.employed, data=training, repeats=25, size=3, decay=0.1,
linout=TRUE)
fitN  <- avNNet(score ~ log.savings + log.income + log.address +
log.employed, data=trainingN, repeats=25, size=3, decay=0.1,
linout=TRUE)
pred <- predict(fit, newdata = testing)
predN <- predict(fitN, newdata = testingN)
str(pred)
head(pred)
head(creditlog)
head(creditlogN)
predNdenorm <- pred*(sd(creditlog$score))+mean(creditlog$score)
RMSE <- sqrt(sum(testing$score-pred)^2/nrow(testing))
RMSEN <- sqrt(sum(testing$score-predNdenorm)^2/nrow(testing))
print(paste(RMSE,RMSEN))
RMSEN2 <- sqrt(sum(testingNdenorm-predNdenorm)^2/nrow(testingN))
creditN <- as.data.frame(scale(credit))
trainingCN <- creditN[inTrain,]; testingCN <- creditN[-inTrain,]
fitCN  <- avNNet(score ~ log.savings + log.income + log.address +
log.employed, data=trainingCN, repeats=25, size=3, decay=0.1,
linout=TRUE)
head(creditN)
fitCN  <- avNNet(score ~ savings + income + time.address +
time.employed, data=trainingCN, repeats=25, size=3, decay=0.1,
linout=TRUE)
predCN <- predict(fitCN, newdata = testingCN)
predCNdenorm <- predCN*(sd(credit$score))+mean(credit$score)
RMSEcn <- sqrt(sum(testingCN$score-predCNdenorm)^2/nrow(testing))
print(paste(RMSE,RMSEcn))
predNdenorm <- predN*(sd(creditlog$score))+mean(creditlog$score)
RMSEN <- sqrt(sum(testing$score-predNdenorm)^2/nrow(testing))
print(paste(RMSE,RMSEN))
mean(testing$score)
head(creditlog)
fitSA <- nnetar(sunspotarea)
plot(forecast(fit,h=20))
plot(forecast(fitSA,h=20))
head(sunspotarea)
?sunspotarea
str(sunspotarea)
sunNorm <- scale(sunspotarea)
sunspotNorm <- ts(sunNorm, start = 1875, end = 2011, frequency = 1)
fitlog <- nnetar(sunspotarea,lambda=0)
plot(forecast(fitlog,h=20))
set.seed(500)
library(MASS)
data <- Boston
apply(data,2,function(x) sum(is.na(x)))
index <- sample(1:nrow(data),round(0.75*nrow(data)))
train <- data[index,]
test <- data[-index,]
lm.fit <- glm(medv~., data=train)
summary(lm.fit)
pr.lm <- predict(lm.fit,test)
maxs <- apply(data, 2, max)
mins <- apply(data, 2, min)
scaled <- as.data.frame(scale(data, center = mins, scale = maxs - mins))
train_ <- scaled[index,]
test_ <- scaled[-index,]
library(neuralnet)
n <- names(train_)
f <- as.formula(paste("medv ~", paste(n[!n %in% "medv"], collapse = " + ")))
nn <- neuralnet(f,data=train_,hidden=c(5,3),linear.output=T)
plot(nn)
str(test_)
?neuralnet
nnTrace <- neuralnet(f,data=train_,hidden=c(5,3), lifesign="minimal", linear.output=T)
nnTrace <- neuralnet(f,data=train_,hidden=c(5,3), lifesign="full", linear.output=T)
nnRep <- neuralnet(f,data=train_,hidden=c(5,3), rep=25, lifesign="full", linear.output=T)
plot(nnRep)
pr.nn <- compute(nn,test_[,1:13])
pr.nn.rep <- compute(nnRep, test_[,1:13])
descaled.pr.nn_ <- pr.nn$net.result*(max(data$medv)-min(data$medv))+min(data$medv)
descaled.pr.nn.rep <- pr.nn.rep$net.result*(max(data$medv)-min(data$medv))+min(data$medv)
test.r <- (test_$medv)*(max(data$medv)-min(data$medv))+min(data$medv)
MSE.nn <- sum((test.r - descaled.pr.nn_)^2)/nrow(test_)
MSE.nn.rep <- sum((test.r - descaled.pr.nn.rep)^2)/nrow(test_)
print(paste(MSE.lm,MSE.nn,MSE.nn.rep))
lm.fit <- glm(medv~., data=train)
pr.lm <- predict(lm.fit,test)
MSE.lm <- sum((pr.lm - test$medv)^2)/nrow(test)
print(paste(MSE.lm,MSE.nn,MSE.nn.rep))
par(mfrow=c(1,3))
plot(test$medv,descaled.pr.nn_,col='red',main='Real vs predicted NN',pch=18,cex=0.7)
abline(0,1,lwd=2)
legend('bottomright',legend='NN',pch=18,col='red', bty='n')
plot(test$medv,pr.lm,col='blue',main='Real vs predicted lm',pch=18, cex=0.7)
abline(0,1,lwd=2)
legend('bottomright',legend='LM',pch=18,col='blue', bty='n', cex=.95)
plot(test$medv,pr.nn.rep,col='red',main='Real vs predicted many model NN',pch=18,cex=0.7)
abline(0,1,lwd=2)
length(test$medv)
length(pr.nn.rep)
plot(test$medv,descaled.pr.nn.rep,col='red',main='Real vs predicted many model NN',pch=18,cex=0.7)
abline(0,1,lwd=2)
legend('bottomright',legend='NN',pch=18,col='red', bty='n')
set.seed(450)
cv.error <- NULL
k <- 10
library(plyr)
pbar <- create_progress_bar('text')
pbar$init(k)
for(i in 1:k){
index <- sample(1:nrow(data),round(0.9*nrow(data)))
train.cv <- scaled[index,]
test.cv <- scaled[-index,]
nn <- neuralnet(f,data=train.cv,hidden=c(5,2),linear.output=T)
pr.nn <- compute(nn,test.cv[,1:13])
pr.nn <- pr.nn$net.result*(max(data$medv)-min(data$medv))+min(data$medv)
test.cv.r <- (test.cv$medv)*(max(data$medv)-min(data$medv))+min(data$medv)
cv.error[i] <- sum((test.cv.r - pr.nn)^2)/nrow(test.cv)
pbar$step()
}
mean(cv.error)
cv.error
boxplot(cv.error,xlab='MSE CV',col='cyan',
border='blue',names='CV error (MSE)',
main='CV error (MSE) for NN',horizontal=TRUE)
str(Boston)
library(caret)
library(fpp)
?train
names(credit)
f <- as.formula(paste("score ~", paste(n[!n %in% "score"], collapse = " + ")))
f
data <- credit
f <- as.formula(paste("score ~", paste(n[!n %in% "score"], collapse = " + ")))
f
data <- credit
f <- as.formula(paste("score ~", paste(n[!n %in% "score"], collapse = " + ")))
library(caret); library(fpp)
n <- names(credit)
n
f <- as.formula(paste("score ~", paste(n[!n %in% c("score", "fte", "single")], collapse = " + ")))
f
?trainControl
modFit <- train(f, data=credit, preProcess= c("center","scale"), method="nnet",
trControl=controlObj)
controlObj <- trainControl(method="cv", number = 10)
modFit <- train(f, data=credit, preProcess= c("center","scale"), method="nnet",
trControl=controlObj)
summary(modelFit)
summary(modFit)
f
print(modFit)
str(modFit)
inTrain <- createDataPartition(y=credit$score,
p=0.9, list=FALSE)
training <- credit[inTrain,]; testing <- credit[-inTrain,]
modFit <- train(f, data=training, preProcess= c("BoxCox", "center","scale"), method="nnet",
trControl=controlObj)
print(modFit)
qplot(score, modFit, data=testing)
pred <- predict(modFit, newdata = testing)
qplot(score, modFit, data=testing)
qplot(score, pred, data=testing)
head(pred)
pred <- predict(modFit$finalModel, newdata = testing)
qplot(score, pred, data=testing)
head(pred)
modFit <- train(f, data=training, preProcess= c("center","scale"), method="nnet",
trControl=controlObj)
pred <- predict(modFit, newdata = testing)
qplot(score, pred, data=testing)
head(testing)
creditDf <- cbind(credit[,!c(4,5)])
head(creditDf)
library(fpp)
?avNNet
?nnetar
library(caret)
?avNNet
library(shiny)
install.packages("shiny")
library(shiny)
setwd("~/R/Courses/JHopkins/Developing Data Products")
?submitButton
?isolate
runApp()
?cat
?browser
